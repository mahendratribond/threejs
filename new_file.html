<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js Frame Customizer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      background-color: #f0f0f0;
    }

    .controls {
      width: 300px;
      background: white;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      /* overflow-y: auto; */
    }

    .preview {
      flex-grow: 1;
      background: #e0e0e0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .preview canvas {
      width: 100%;
      height: 100%;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      margin-bottom: 5px;
    }

    .control-group input,
    .control-group select {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
    }

    .control-group input[type="checkbox"] {
      width: auto;
      margin-right: 10px;
    }

    .texture-slider {
      display: flex;
      overflow-x: auto;
      white-space: nowrap;
    }

    .texture-option {
      display: inline-block;
      width: 60px;
      height: 60px;
      margin: 5px;
      cursor: pointer;
      border: 2px solid transparent;
    }

    .texture-option.selected {
      border-color: #007bff;
    }

    .submit-button {
      width: 100%;
      padding: 10px;
      background-color: #007bff;
      color: white;
      border: none;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div class="controls">
    <div class="control-group">
      <label for="frameSize">Frame Size</label>
      <select id="frameSize">
        <option value="600">600</option>
        <option value="900">900</option>
        <option value="1000">1000</option>
        <option value="1200">1200</option>
        <option value="1500">1500</option>
      </select>
    </div>
    <div class="control-group">
      <label for="baseColor">Base Color</label>
      <select id="baseColor">
        <option value="#000000">Black</option>
        <option value="#ffffff">White</option>
      </select>
    </div>
    <div class="control-group">
      <label for="frameTexture">Frame Texture</label>
      <div id="frameTexture" class="texture-slider">
        <img src="./assets/images/borders/art.jpg" class="texture-option" data-texture="art.jpg" />
        <img src="./assets/images/borders/Dark_Wood.jpg" class="texture-option" data-texture="Dark_Wood.jpg" />
        <img src="./assets/images/borders/Lighter_Wood.jpg" class="texture-option" data-texture="Lighter_Wood.jpg" />
        <img src="./assets/images/borders/Red_Cherry_Wood.jpg" class="texture-option"
          data-texture="Red_Cherry_Wood.jpg" />
      </div>
    </div>
    <div class="control-group">
      <label for="frameColor">Frame Color</label>
      <select id="frameColor">
        <option value="#ff0000">Red</option>
        <option value="#00ff00">Green</option>
        <option value="#0000ff">Blue</option>
        <option value="#ffff00">Yellow</option>
        <option value="#ff00ff">Magenta</option>
        <option value="#00ffff">Cyan</option>
      </select>
    </div>
    <div class="control-group">
      <label for="headerToggle">
        <input type="checkbox" id="headerToggle" checked /> Header
      </label>
    </div>
    <div class="control-group">
      <label for="imageUpload">Upload SES Image</label>
      <input type="file" id="imageUpload" />
    </div>
    <button class="submit-button" onclick="submitForm()">Submit</button>
  </div>
  <div class="preview">
    <canvas id="canvas"></canvas>
  </div>

  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.rawgit.com/mrdoob/three.js/r128/examples/js/loaders/ColladaLoader.js"></script> -->
  <script type="importmap">
      {
        "imports": {
          "three": "./three/build/three.module.js",
          "three/addons/": "./three/examples/jsm/"
        }
      }
    </script>
  <script type="module">
    import * as THREE from "three";
    import Stats from 'three/addons/libs/stats.module.js';

    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
    import { ColladaLoader } from "three/addons/loaders/ColladaLoader.js";

    let mesh, renderer, scene, camera, controls, elf, stats;
    let gui,
      guiExposure = null;
    const state = {
      frameSize: 600,
      baseColor: "#000000",
      frameTexture: "texture1.jpg",
      frameColor: "#ff0000",
      headerVisible: true,
      image: null,
    };
    const toneMappingOptions = {
      None: THREE.NoToneMapping,
      Linear: THREE.LinearToneMapping,
      Reinhard: THREE.ReinhardToneMapping,
      Cineon: THREE.CineonToneMapping,
      ACESFilmic: THREE.ACESFilmicToneMapping,
      AgX: THREE.AgXToneMapping,
      Neutral: THREE.NeutralToneMapping,
      Custom: THREE.CustomToneMapping,
    };

    init().catch(function (err) {
      console.error(err);
    });

    const hdrEquirect = new RGBELoader()
      .setPath("./assets/images/")
      .load("venice_sunset_1k.hdr", function () {
        hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
        render();
      });

    async function init() {
      const params = {
        color: 0xffffff,
        transmission: 1,
        opacity: 1,
        metalness: 0,
        roughness: 0,
        ior: 1.5,
        thickness: 0.01,
        specularIntensity: 1,
        specularColor: 0xffffff,
        envMapIntensity: 1,
        lightIntensity: 1,
        exposure: 1,
        blurriness: 0.3,
        toneMapping: "AgX",
      };

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      // renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setSize(window.innerWidth - 300, window.innerHeight);
      renderer.setAnimationLoop(animate);

      document.body.appendChild(renderer.domElement);

      renderer.toneMapping = toneMappingOptions[params.toneMapping];
      renderer.toneMappingExposure = params.exposure;


      stats = new Stats();
      document.body.appendChild(stats.dom);

      // Set CustomToneMapping to Uncharted2
      // source: http://filmicworlds.com/blog/filmic-tonemapping-operators/

      THREE.ShaderChunk.tonemapping_pars_fragment =
        THREE.ShaderChunk.tonemapping_pars_fragment.replace(
          "vec3 CustomToneMapping( vec3 color ) { return color; }",

          `#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )

              float toneMappingWhitePoint = 1.0;

              vec3 CustomToneMapping( vec3 color ) {
                  color *= toneMappingExposure;
                  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );

              }`
        );

      scene = new THREE.Scene();
      scene.backgroundBlurriness = params.blurriness;

      // camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
      camera = new THREE.PerspectiveCamera(
        30,
        window.innerWidth / window.innerHeight
      );
      camera.position.set(-1.8, 0.6, 2.7);

      controls = new OrbitControls(camera, renderer.domElement);

      // controls.minPolarAngle = Math.PI / 2; // Adjust the value as needed
      // controls.maxPolarAngle = Math.PI / 2; // Adjust the value as needed

      // Restrict the horizontal rotation (azimuthal angle)
      controls.minAzimuthAngle = -Math.PI / 2; // Adjust the value as needed
      controls.maxAzimuthAngle = Math.PI / 2;

      camera.position.z = 100;

      controls.addEventListener("change", render); // use if there is no animation loop
      controls.target.set(0, 0, -0.2);
      controls.update();

      const rgbeLoader = new RGBELoader().setPath("./assets/images/");

      const loader = new ColladaLoader().setPath("./assets/models/");
      // const gltfLoader = new GLTFLoader().setPath( './three/examples/models/gltf/DamagedHelmet/glTF/' );
      const textureLoader = new THREE.TextureLoader();
      const [texture, collada, texture_border] = await Promise.all([
        rgbeLoader.loadAsync("venice_sunset_1k.hdr"),
        loader.loadAsync("600 Unit v2.dae"),
        textureLoader.load("./assets/images/borders/art.jpg"),
      ]);

      elf = collada.scene;
      // environment
      elf.scale.set(0.3, 0.3, 0.3);
      elf.position.set(0, -20, 0);
      texture.mapping = THREE.EquirectangularReflectionMapping;
      elf.castShadow = true;
      scene.background = texture;
      scene.environment = texture;

      {
        const radius = 50;
        const height = 35;
        const lightIntensity = 0.9;

        for (let i = 0; i < 4; i++) {
          const angle = (i / 4) * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;

          const directionalLight = new THREE.DirectionalLight(
            0xffffff,
            i % 2 == 0 ? lightIntensity : 1.5
          );
          directionalLight.position.set(x, height, z);

          const targetObject = new THREE.Object3D();
          targetObject.position.x = 0;
          targetObject.position.y = -20;
          // Set target to the position of the elf model
          scene.add(targetObject);

          directionalLight.target = targetObject;
          directionalLight.target.updateMatrixWorld();

          scene.add(directionalLight);

          const directionalLightHelper = new THREE.DirectionalLightHelper(
            directionalLight,
            5
          );
          // scene.add(directionalLightHelper);
        }
      }

      // {
      //   const radius = 50;
      //   const height = 5;
      //   const lightIntensity = 1;

      //   for (let i = 0; i < 8; i++) {
      //     const angle = (i / 8) * Math.PI * 2;
      //     const x = Math.cos(angle) * radius;
      //     const z = Math.sin(angle) * radius;

      //     const directionalLight = new THREE.DirectionalLight(
      //       0xffffff,
      //       i % 2 == 0 ? lightIntensity : 0.5
      //     );
      //     directionalLight.position.set(x, height, z);

      //     const targetObject = new THREE.Object3D();
      //     targetObject.position.copy(elf.position); // Set target to the position of the elf model
      //     scene.add(targetObject);

      //     directionalLight.target = targetObject;
      //     directionalLight.target.updateMatrixWorld();

      //     scene.add(directionalLight);

      //     const directionalLightHelper = new THREE.DirectionalLightHelper(
      //       directionalLight,
      //       5
      //     );
      //     scene.add(directionalLightHelper);
      //   }
      // }

      const node = elf.getObjectByName("_0001-20-001");

      // const nodeClone = node.clone();
      // nodeClone.scale.set(0.3, 0.3, 0.3);
      // scene.add(nodeClone);
      // nodeClone.position.x = 10;
      // nodeClone.position.y = 0;
      // nodeClone.position.y = 0;

      elf.traverse(function (child) {
        if (child.name == "_0001-20-001") {
          console.log(child);
          console.log("material", child.material);

          console.log("------------------------------");
          const greenMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000, // Green color
            metalness: 0.5, // Adjust for desired metallic effect
            roughness: 0.5, // Adjust for desired shininess
            opacity: 0.5,
            transparent: true,
          });

          const whitematerial = new THREE.MeshStandardMaterial({
            color: 0x808080, // Green color
            metalness: 0.5, // Adjust for desired metallic effect
            roughness: 0.5, // Adjust for desired shininess
          });

          child.material = [child.material[0], greenMaterial];

          console.log("material", child.material);
          // let oldMat = child.material;

          // const geometry = new THREE.SphereGeometry(20, 64, 32);

          // const texture = new THREE.CanvasTexture(generateTexture());
          // texture.magFilter = THREE.NearestFilter;
          // texture.wrapT = THREE.RepeatWrapping;
          // texture.wrapS = THREE.RepeatWrapping;
          // texture.repeat.set(1, 3.5);
          // const material = new THREE.MeshPhysicalMaterial({
          //   color: params.color,
          //   metalness: params.metalness,
          //   roughness: params.roughness,
          //   ior: params.ior,
          //   alphaMap: texture,
          //   envMap: hdrEquirect,
          //   envMapIntensity: params.envMapIntensity,
          //   transmission: params.transmission, // use material.transmission for glass materials
          //   specularIntensity: params.specularIntensity,
          //   specularColor: params.specularColor,
          //   opacity: params.opacity,
          //   side: THREE.DoubleSide,
          //   transparent: true,
          //   texture
          // });

          texture_border.encoding = THREE.sRGBEncoding;
          texture_border.minFilter = 1008;
          texture_border.magFilter = THREE.LinearFilter;
          texture_border.colorSpace = "srgb";

          texture_border.wrapT = THREE.RepeatWrapping;
          texture_border.wrapS = THREE.RepeatWrapping;

          const material = new THREE.MeshPhongMaterial({
            name: "newMat",
            specular: 3355443,
            map: texture_border,
            shininess: 0.5,
          });

          child.material = [material, greenMaterial];

          console.log("new Material", material);

          // let n = child.copy();
          // scene.add(n)
          // child.material = oldMat;

          child.material.needsUpdate = true;
        }
      });

      // model
      scene.add(collada.scene);

      if (elf.rotation.x > Math.PI / 2) {
        elf.rotation.x = Math.PI / 2;
      } else if (elf.rotation.x < -Math.PI / 2) {
        elf.rotation.x = -Math.PI / 2;
      }

      if (elf.rotation.y > Math.PI / 2) {
        elf.rotation.y = Math.PI / 2;
      } else if (elf.rotation.y < -Math.PI / 2) {
        elf.rotation.y = -Math.PI / 2;
      }

      // elf.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, elf.rotation.x));
      // elf.rotation.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, elf.rotation.y));

      // {

      // 	const geometry = new THREE.SphereGeometry( 20, 64, 32 );

      // const texture = new THREE.CanvasTexture( generateTexture() );
      // texture.magFilter = THREE.NearestFilter;
      // texture.wrapT = THREE.RepeatWrapping;
      // texture.wrapS = THREE.RepeatWrapping;
      // texture.repeat.set( 1, 3.5 );
      // const material = new THREE.MeshPhysicalMaterial( {
      // 					color: params.color,
      // 					metalness: params.metalness,
      // 					roughness: params.roughness,
      // 					ior: params.ior,
      // 					alphaMap: texture,
      // 					envMap: hdrEquirect,
      // 					envMapIntensity: params.envMapIntensity,
      // 					transmission: params.transmission, // use material.transmission for glass materials
      // 					specularIntensity: params.specularIntensity,
      // 					specularColor: params.specularColor,
      // 					opacity: params.opacity,
      // 					side: THREE.DoubleSide,
      // 					transparent: true
      // 				} );

      // 				mesh = new THREE.Mesh( geometry, material );
      // 				scene.add( mesh );

      // }

      render();

      window.addEventListener("resize", onWindowResize);
    }
    function generateTexture() {
      const canvas = document.createElement("canvas");
      canvas.width = 2;
      canvas.height = 2;

      const context = canvas.getContext("2d");
      context.fillStyle = "white";
      context.fillRect(0, 1, 2, 1);

      return canvas;
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;

      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

      render();
    }

    function render() {
      renderer.render(scene, camera);
      stats.update();
    }

    // Event listeners for controls
    document
      .getElementById("frameSize")
      .addEventListener("change", function (event) {
        const size = event.target.value;
        console.log(size);

        if (elf) {
          const scale = size / 600; // Assuming 600 is the base size
          elf.scale.set(scale, scale, scale);
        }
      });

    document
      .getElementById("baseColor")
      .addEventListener("change", function (event) {
        const color = event.target.value;
        if (model) {
          model.traverse(function (child) {
            if (child.isMesh && child.name === "base") {
              child.material.color.set(color);
            }
          });
        }
      });

    document.querySelectorAll(".texture-option").forEach(function (element) {
      element.addEventListener("click", function () {
        document.querySelectorAll(".texture-option").forEach(function (el) {
          el.classList.remove("selected");
        });
        element.classList.add("selected");
        const textureFile = element.getAttribute("data-texture");
        console.log(textureFile);



        elf.traverse(function (child) {
          if (child.name == "_0001-20-001" || child.name == "_0001-20-002" || child.name == "Solid2_1_.2" || child.name == "Solid2_1_.1") {

            const shadow = new THREE.MeshStandardMaterial({
              color: 0x000000, // Green color
              metalness: 0.5, // Adjust for desired metallic effect
              roughness: 0.5, // Adjust for desired shininess
              opacity: 0.5,
              transparent: true,
            });

            child.material = [child.material[0], shadow];


            const texture_border = new THREE.TextureLoader().load("./assets/images/borders/" + textureFile, function () {
              texture_border.encoding = THREE.sRGBEncoding;
              texture_border.minFilter = 1008;
              texture_border.magFilter = THREE.LinearFilter;
              texture_border.colorSpace = "srgb";

              texture_border.wrapT = THREE.RepeatWrapping;
              texture_border.wrapS = THREE.RepeatWrapping;

              const material = new THREE.MeshPhongMaterial({
                name: "newMat",
                specular: 3355443,
                map: texture_border,
                shininess: 0.5,
              });
              console.log(material);

              child.material = [material, shadow];

              child.material.needsUpdate = true;

            });


          }
        });

      });
    });

    document
      .getElementById("frameColor")
      .addEventListener("change", function (event) {
        const color = event.target.value;
        if (model) {
          model.traverse(function (child) {
            if (child.isMesh && child.name === "frame") {
              child.material.color.set(color);
            }
          });
        }
      });

    document
      .getElementById("headerToggle")
      .addEventListener("change", function (event) {
        const isChecked = event.target.checked;
        if (model) {
          model.traverse(function (child) {
            if (child.isMesh && child.name === "header") {
              child.visible = isChecked;
            }
          });
        }
      });

    document
      .getElementById("imageUpload")
      .addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (file && model) {
          const reader = new FileReader();
          reader.onload = function (e) {
            const texture = new THREE.TextureLoader().load(e.target.result);
            model.traverse(function (child) {
              if (child.isMesh && child.name === "image") {
                child.material.map = texture;
                child.material.needsUpdate = true;
              }
            });
          };
          reader.readAsDataURL(file);
        }
      });

    function submitForm() {
      alert("Form Submitted!");
    }


    function animate() {
      renderer.render(scene, camera);
      stats.update();
    }

    // Initial render
    animate();
  </script>
</body>

</html>