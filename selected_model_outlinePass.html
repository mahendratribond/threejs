<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - ShadowMapViewer example </title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
</head>

<body>

	<div id="info">

	</div>
	<!-- "three": "./three/build/three.webgpu.js", -->
	<!-- "three": "./three/build/three.module.js", -->
	<script type="importmap">

        {
            "imports": {
                "three": "./three/build/three.module.js",
                "three/tsl": "./three/build/three.webgpu.js",
                "three/addons/": "./three/examples/jsm/"
            }
        }
    </script>
	<script type="module">

		import * as THREE from 'three';

		import Stats from 'three/addons/libs/stats.module.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
		import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
		import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
		import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
		import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
		import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
		import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';


		let container, stats;
		let camera, scene, renderer, controls;
		let composer, effectFXAA, outlinePass, model;

		let selectedObjects = [];

		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();

		const glb3d = new THREE.Object3D();
		const group = new THREE.Group();

		const params = {
			edgeStrength: 3.0,
			edgeGlow: 0.0,
			edgeThickness: 1.0,
			pulsePeriod: 0,
			rotate: false,
			usePatternTexture: false
		};




		// Init gui

		const gui = new GUI({ width: 280 });

		gui.add(params, 'edgeStrength', 0.01, 10).onChange(function (value) {

			outlinePass.edgeStrength = Number(value);

		});

		gui.add(params, 'edgeGlow', 0.0, 1).onChange(function (value) {

			outlinePass.edgeGlow = Number(value);

		});

		gui.add(params, 'edgeThickness', 1, 4).onChange(function (value) {

			outlinePass.edgeThickness = Number(value);

		});

		gui.add(params, 'pulsePeriod', 0.0, 5).onChange(function (value) {

			outlinePass.pulsePeriod = Number(value);

		});

		gui.add(params, 'rotate');

		gui.add(params, 'usePatternTexture').onChange(function (value) {

			outlinePass.usePatternTexture = value;

		});

		function Configuration() {

			this.visibleEdgeColor = '#ffffff';
			this.hiddenEdgeColor = '#190a05';

		}

		const conf = new Configuration();

		gui.addColor(conf, 'visibleEdgeColor').onChange(function (value) {

			outlinePass.visibleEdgeColor.set(value);

		});

		gui.addColor(conf, 'hiddenEdgeColor').onChange(function (value) {

			outlinePass.hiddenEdgeColor.set(value);

		});

		init();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			const width = window.innerWidth;
			const height = window.innerHeight;

			renderer = new THREE.WebGLRenderer();
			renderer.shadowMap.enabled = true;
			// todo - support pixelRatio in this demo
			renderer.setSize(width, height);
			renderer.setAnimationLoop(animate);
			document.body.appendChild(renderer.domElement);

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
			camera.position.set(0, 0, 8);

			controls = new OrbitControls(camera, renderer.domElement);
			controls.minDistance = 5;
			controls.maxDistance = 20;
			controls.enablePan = false;
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;

			//

			scene.add(new THREE.AmbientLight(0xaaaaaa, 0.6));

			const light = new THREE.DirectionalLight(0xddffdd, 2);
			light.position.set(1, 1, 1);
			light.castShadow = true;
			light.shadow.mapSize.width = 1024;
			light.shadow.mapSize.height = 1024;

			const d = 10;

			light.shadow.camera.left = - d;
			light.shadow.camera.right = d;
			light.shadow.camera.top = d;
			light.shadow.camera.bottom = - d;
			light.shadow.camera.far = 1000;

			scene.add(light);

			scene.add(group);

			// Define scale variables
			let scaleValue = 0.002; // Add a variable to hold the scale value

			const gltfLoader = new GLTFLoader();
			// When the model is loaded
			gltfLoader.load('./assets/models/glb/Model_661.glb', function (model_load) {
				model = model_load.scene;
				model.position.y = -1.4;
				model.scale.set(scaleValue, scaleValue, scaleValue); // Set the initial scale
				group.add(model);
				console.log('model', model);
			});

			stats = new Stats();
			container.appendChild(stats.dom);

			// postprocessing

			composer = new EffectComposer(renderer);

			const renderPass = new RenderPass(scene, camera);
			composer.addPass(renderPass);

			outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
			composer.addPass(outlinePass);

			const outputPass = new OutputPass();
			composer.addPass(outputPass);

			effectFXAA = new ShaderPass(FXAAShader);
			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
			composer.addPass(effectFXAA);

			window.addEventListener('resize', onWindowResize);

			renderer.domElement.style.touchAction = 'none';
			renderer.domElement.addEventListener('pointermove', onPointerMove);

			function onPointerMove(event) {

				if (event.isPrimary === false) return;

				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

				checkIntersection();

			}

			function addSelectedObject(object) {

				selectedObjects = [];
				selectedObjects.push(object);

			}

			function findParentNodeByName(node, parentName, isVisible = null) {
				// Base case: If the current node has no parent, return null
				if (!node.parent) return null;

				// Check if parentName is an array or a string
				const isMatch = Array.isArray(parentName) ? parentName.includes(node.parent.name) : node.parent.name === parentName;

				// If the current node's parent matches the name (or one of the names in the array), return the parent node
				if (isVisible) {
					if (isMatch && node.parent.visible) {
						return node.parent; // Return the current node if its parent name matches
					}
				}
				else {
					if (isMatch) {
						return node.parent; // Return the current node if its parent name matches
					}
				}

				// Recursively search for the matching node in the children
				const result = findParentNodeByName(node.parent, parentName, isVisible);
				if (result) return result; // If a match is found, return it

				// If no match is found, return null
				return null;
			}

			function checkIntersection() {

				raycaster.setFromCamera(mouse, camera);

				// const intersects = raycaster.intersectObject(['Model_661'], true);
				const intersects = raycaster.intersectObject(scene, true);

				if (intersects.length > 0) {

					const selectedObject = intersects[0].object;

					let selectedModel = findParentNodeByName(selectedObject, 'Model_661');

					addSelectedObject(selectedModel);
					console.log(selectedObjects)

					const boxHelper = new THREE.BoxHelper(selectedModel, 0xffff00);  // Yellow color
					scene.add(boxHelper);

					// When deselecting, remove the bounding box helper
					function deselectObject() {
						scene.remove(boxHelper);
					}

					// outlinePass.edgeStrength = 1.0;  // Lowering strength for a more subtle outline
					// outlinePass.edgeThickness = 0.5;  // Reducing the thickness to match the model scale
					// outlinePass.edgeGlow = 0.0;       // No glow for a cleaner outline
					// outlinePass.pulsePeriod = 0;      // Disable pulsing effect
					// outlinePass.visibleEdgeColor.set('#00ff00');  // Green visible edge
					// outlinePass.hiddenEdgeColor.set('#000000');


					// outlinePass.selectedObjects = selectedObjects;

				} else {

					// outlinePass.selectedObjects = [];

				}

			}

		}

		function onWindowResize() {

			const width = window.innerWidth;
			const height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
			composer.setSize(width, height);

			effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);

		}

		function animate() {

			// stats.begin();

			// const timer = performance.now();

			// if (params.rotate) {

			// 	group.rotation.y = timer * 0.0001;

			// }

			controls.update();

			composer.render();

			// stats.end();

		}

	</script>
</body>

</html>