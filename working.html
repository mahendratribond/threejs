<!DOCTYPE html>
<html>

<head>
    <title>DAE Viewer with Dynamic Textures</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }


        a {
            color: #ff0;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        button {
            cursor: pointer;
            text-transform: uppercase;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
            z-index: 1;
            /* TODO Solve this in HTML */
        }

        a,
        button,
        input,
        select {
            pointer-events: auto;
        }

        .lil-gui {
            z-index: 2 !important;
            /* TODO Solve this in HTML */
        }

        @media all and (max-width: 640px) {
            .lil-gui.root {
                right: auto;
                top: auto;
                max-height: 50%;
                max-width: 80%;
                bottom: 0;
                left: 0;
            }
        }

        #overlay {
            position: absolute;
            font-size: 16px;
            z-index: 2;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.7);
        }

        #overlay button {
            background: transparent;
            border: 0;
            border: 1px solid rgb(255, 255, 255);
            border-radius: 4px;
            color: #ffffff;
            padding: 12px 18px;
            text-transform: uppercase;
            cursor: pointer;
        }

        #notSupported {
            width: 50%;
            margin: auto;
            background-color: #f00;
            margin-top: 20px;
            padding: 10px;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div id="info">
        <!-- <input type="color" id="borderColorPicker" onchange="changeBorderColor()" /> -->

        <button onclick="changeTexture('adidas.jpg')">Change to Adidas</button>
        <button onclick="changeTexture('tree1.jpeg')">Change to tree1</button>
        <button onclick="changeTexture('sunset.jpeg')">Change to sunset</button>
        <button onclick="changeTexture('sunset2.webp')">Change to sunset2</button>
        <button onclick="changeTexture('mount.jpeg')">Change to mount</button>
        <button onclick="changeTexture('trees.jpg')">Change to Trees</button>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "./three/build/three.module.js",
                "three/addons/": "./three/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ColladaLoader } from 'three/addons/loaders/ColladaLoader.js';

        const container = document.getElementById('container');

        let renderer, scene, camera, stats;
        let elf;

        // Declare params globally
        let params = {
            scale: 0.4,
            rotateX: 0,
            rotateY: 0,
            rotateZ: 0,
            moveX: 0,
            moveY: 0,
            moveZ: 0,
            borderColor: '#d6d6d6', // Default color
            clear: clear // Clear functionality
        };


        init();

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            container.appendChild(renderer.domElement);

            stats = new Stats();
            container.appendChild(stats.dom);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 120;

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 50;
            controls.maxDistance = 200;

            scene.add(new THREE.AmbientLight(0xffffff));

            const dirLight1 = new THREE.DirectionalLight(0xffffff, 3);
            dirLight1.position.set(1, 0.75, 0.5);
            scene.add(dirLight1);

            const dirLight2 = new THREE.DirectionalLight(0xffffff, 3);
            dirLight2.position.set(-1, 0.75, -0.5);
            scene.add(dirLight2);

            // Load Collada file
            const loader = new ColladaLoader();
            loader.load('./texture.dae', function (collada) {
                elf = collada.scene;
                elf.scale.set(0.4, 0.4, 0.4); // Adjust scaling as needed
                elf.position.y = -25; // Move the object down along the Y-axis
                scene.add(elf);
            });

            window.addEventListener('resize', onWindowResize);

            // Initialize GUI and attach parameters
            const gui = new GUI();
            gui.add(params, 'scale', 0.1, 5).onChange(updateScale);

            gui.add(params, 'rotateX', -Math.PI, Math.PI).onChange(value => updateRotation('rotateX', value));
            gui.add(params, 'rotateY', -Math.PI, Math.PI).onChange(value => updateRotation('rotateY', value));
            gui.add(params, 'rotateZ', -Math.PI, Math.PI).onChange(value => updateRotation('rotateZ', value));
            gui.add(params, 'moveX', -100, 100).onChange(value => updatePosition('moveX', value));
            gui.add(params, 'moveY', -100, 100).onChange(value => updatePosition('moveY', value));
            gui.add(params, 'moveZ', -100, 100).onChange(value => updatePosition('moveZ', value));

            gui.addColor(params, 'borderColor').onChange(updateBorderColor);
            gui.add(params, 'clear');
            gui.open();

            // Add keyboard event listener
            window.addEventListener('keydown', onKeyDown);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.render(scene, camera);
            stats.update();
        }

        function onKeyDown(event) {
            if (!elf) return; // Ensure elf is loaded

            const step = 1; // Adjust the step size as needed
            const rotationStep = 0.1; // Adjust the rotation step as needed

            switch (event.key) {
                case 'ArrowUp':
                    elf.position.z -= step;
                    break;
                case 'ArrowDown':
                    elf.position.z += step;
                    break;
                case 'ArrowLeft':
                    elf.position.x -= step;
                    break;
                case 'ArrowRight':
                    elf.position.x += step;
                    break;
                case 'w':
                    elf.position.y += step;
                    break;
                case 's':
                    elf.position.y -= step;
                    break;
                case 'a':
                    elf.rotation.y -= rotationStep;
                    break;
                case 'd':
                    elf.rotation.y += rotationStep;
                    break;
                case 'r':
                    elf.rotation.x -= rotationStep;
                    break;
                case 'f':
                    elf.rotation.x += rotationStep;
                    break;
                case 'q':
                    elf.rotation.z -= rotationStep;
                    break;
                case 'e':
                    elf.rotation.z += rotationStep;
                    break;
                case '+':
                    elf.scale.multiplyScalar(1.1); // Increase size
                    break;
                case '-':
                    elf.scale.multiplyScalar(0.9); // Decrease size
                    break;
            }
        }

        function updateScale(value) {
            if (elf) elf.scale.set(value, value, value);
        }

        function updateRotation(axis, value) {
            if (elf) {
                switch (axis) {
                    case 'rotateX':
                        elf.rotation.x = value;
                        break;
                    case 'rotateY':
                        elf.rotation.y = value;
                        break;
                    case 'rotateZ':
                        elf.rotation.z = value;
                        break;
                }
            }
        }


        function updatePosition(axis, value) {
            if (elf) {
                switch (axis) {
                    case 'moveX':
                        elf.position.x = value;
                        break;
                    case 'moveY':
                        elf.position.y = value;
                        break;
                    case 'moveZ':
                        elf.position.z = value;
                        break;
                }
            }
        }

        // Function to update border color from params
        function updateBorderColor(borderColor) {
            if (!elf) return; // Ensure elf is loaded

            elf.traverse(function (child) {
                if (child.isMesh && isBorderPart(child)) {
                    child.material.color.set(borderColor);
                    child.material.needsUpdate = true; // Ensure the material updates
                }
            });
        }

        function clear() {
            if (elf) {
                elf.scale.set(params.scale, params.scale, params.scale);
                elf.rotation.set(params.rotateX, params.rotateY, params.rotateZ);
                elf.position.set(params.moveX, params.moveY, params.moveZ);

                elf.traverse(function (child) {
                    if (child.isMesh) {
                        child.material.color.set(params.borderColor);
                        child.material.needsUpdate = true;
                    }
                });
            }

            Object.assign(params, {
                scale: 0.4,
                rotateX: 0,
                rotateY: 0,
                rotateZ: 0,
                moveX: 0,
                moveY: 0,
                moveZ: 0,
                borderColor: '#d6d6d6'
            });
        }

        // Function to check if the mesh is part of the inner nodes
        function isInnerPart(mesh) {
            // Add logic to identify the inner part meshes
            // For example, you can check the name or ID of the mesh
            const innerNames = ['Cube.2', 'Cube.1']; // Replace with actual names or IDs of inner meshes
            return innerNames.includes(mesh.name);
        }

        // Function to check if the mesh is part of the border nodes
        function isBorderPart(mesh) {
            // Add logic to identify the border part meshes
            const borderNames = ['_0001-20-001', '_0001-20-002', 'Solid2_1_.2', 'Solid2_1_.1']; // Replace with actual names or IDs of border meshes
            return borderNames.includes(mesh.name);
        }

        // Function to change texture dynamically
        window.changeTexture = function (image) {
            if (!elf) return; // Ensure elf is loaded

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(image, function (texture) {
                elf.traverse(function (child) {
                    if (child.isMesh && isInnerPart(child)) {
                        child.material.map = texture;
                        child.material.needsUpdate = true;
                    }
                });
            });
        }

        // Function to change border color dynamically
        window.changeBorderColor = function () {
            if (!elf) return; // Ensure elf is loaded

            const borderColor = document.getElementById('borderColorPicker').value;

            updateBorderColor(borderColor);

        }

    </script>
</body>

</html>